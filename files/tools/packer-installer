#!/usr/bin/python3
# -*- coding: UTF-8 -*-
from tinyscript import *

from packers import *


__author__      = "Alexandre D'Hondt"
__email__       = "alexandre.dhondt@gmail.com"
__version__     = "1.0.0"
__copyright__   = ("A. D'Hondt", 2021)
__license__     = "gpl-3.0"
__doc__         = """
This utility aims to facilitate packers' install according to the YAML packers data file.
"""
__description__ = "A tool for easily installing packers based on a YML config file."


def install(packer, instructions):
    logger.info("Installing %s..." % packer)
    tmp, ubin = ts.Path("/tmp"), ts.Path("/usr/bin")
    p = packer.lower()
    result, rm = None, True
    for cmd, arg in instructions.items():
        if result and not result.exists():
            raise ValueError("Last command's result does not exist (%s)" % result)
        # simple install through APT
        if cmd == "apt":
            run("apt -qy install %s" % arg)
        # change to the given dir (starting from the reference /tmp directory if no command was run before)
        elif cmd == "cd":
            result = (result or tmp).joinpath(arg)
        # copy a file from the previous location (or /tmp if not defined) to /usr/bin,
        #  making the destination file executable
        elif cmd == "copy":
            src, dst = (result or tmp).joinpath(arg), ubin.joinpath(arg)
            if run("cp %s %s" % (src, dst))[-1] == 0:
                run("chmod +x %s" % dst)
        # make a symbolink link in /usr/bin (if relative path) relatively to the previous considered location
        elif cmd == "ln":
            r = ubin.joinpath(p)
            run("ln -s %s %s" % (result.joinpath(arg), r))
            result = r
        # compile a C project
        elif cmd == "make":
            cwd = os.getcwd()
            logger.debug("cd %s" % result)
            os.chdir(str(result))
            if not result.is_dir():
                raise ValueError("Got a file ; should have a folder")
            files = [x.filename for x in result.listdir()]
            if "Makefile" in files:
                if "configure.sh" in files:
                    if run("chmod +x configure.sh")[-1] == 0:
                        run("./configure.sh")
                if run("make")[-1] == 0:
                    run("make install")
            elif "make.sh" in files:
                if run("chmod +x make.sh")[-1] == 0:
                    run("sh -c './make.sh'")
            result = result.joinpath(arg)
            logger.debug("cd %s" % cwd)
            os.chdir(cwd)
        # move the previous location to /usr/bin (if relative path), make it executable if it is a file
        elif cmd == "move":
            if result is None:
                result = tmp.joinpath("%s.*" % p)
            r = ubin.joinpath(arg)
            if run("mv %s %s" % (result, r))[-1] == 0 and r.is_file():
                run("chmod +x %s" % r)
            result = r
        # remove a given directory (then bypassing the default removal at the end of all commands)
        elif cmd == "rm":
            run("rm -rf %s" % ts.Path(arg))
            rm = False
        # create a shell script to execute Bash code and make it executable
        elif cmd == "sh":
            result = ubin.joinpath(p)
            arg = "#!/bin/bash\n%s" % arg
            logger.debug("echo -en '%s' > %s" % (arg, result))
            try:
                result.write_text(arg)
                run("chmod +x %s" % result)
            except PermissionError:
                logger.error("bash: %s: Permission denied" % result)
        # decompress a ZIP archive to the given location (absolute or relative to /tmp)
        elif cmd == "unzip":
            if result is None:
                result = tmp.joinpath("%s.zip" % p)
            if result and result.extension == ".zip":
                r = tmp.joinpath(arg)
                run("unzip -qqo %s -d %s" % (result, r))
                result.remove()
                result = r
            else:
                raise ValueError("Not a ZIP file")
            if result and result.is_dir():
                ld = list(result.listdir())
                while len(ld) == 1 and ld[0].is_dir():
                    result = ld[0]
                    ld = list(result.listdir())
        # download a resource, possibly downloading 2-stage generated download links (in this case, the list is handled
        #  by downloading the URL from the first element then matching the second element in the URL's found in the
        #  downloaded Web page
        elif cmd == "wget":
            # (2-stage) dynamic download link
            rc = 0
            if isinstance(arg, list):
                url = arg[0]
                for line in run("wget -qO - %s" % url)[0].splitlines():
                    line = line.decode()
                    if ".zip" in line:
                        print(line)
                    m = re.search(r"href\s+=\s+(?P<q>[\"'])(.*)(?P=q)", line)
                    if m is not None:
                        url = m.group(1)
                        print(url)
                        if ts.Path(ts.urlparse(url).path).stem == (arg[1] if len(arg) > 1 else p):
                            break
                        url = arg[0]
                if url != arg[0]:
                    result = tmp.joinpath(p + ts.Path(ts.urlparse(url).path).extension)
                    run("wget -q -O %s %s" % (result, url))[-1]
            # normal link
            else:
                result = tmp.joinpath(p + ts.Path(ts.urlparse(arg).path).extension)
                run("wget -q -O %s %s" % (result, arg))[-1]
    if rm:
        run("rm -rf %s" % tmp.joinpath(p))


def run(cmd):
    logger.debug(cmd)
    out, err, retc = ts.execute(cmd, returncode=True)
    if out and len(out) < 256:
        logger.debug(out.decode().strip())
    if err:
        err = err.decode().strip()
        if len(err.split("\n")) > 1 or not err.startswith("WARNING"):
            logger.error(err)
    elif retc != 0:
        logger.error("command failed")
    return out, err, retc


if __name__ == '__main__':
    parser.add_argument("-c", "--config", type=ts.yaml_config, default="packers.yml",
                        help="YAML configuration file for installing packers")
    parser.add_argument("-p", "--packer", nargs="*", help="specific packer to install")
    initialize()
    for packer, config in args.config.items():
        if args.packer and packer.lower() not in list(map(lambda x: x.lower(), args.packer or [])):
            logger.debug("Skipping %s..." % packer)
            continue
        try:
            install(packer, config['install'])
        except:
            logger.critical("Packer install failed: %s" % packer)

