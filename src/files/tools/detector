#!/usr/bin/python3
# -*- coding: UTF-8 -*-
from pbox import *
from pbox.__info__ import *
from pbox.common.utils import *
from tinyscript import *
from tinyscript.report import *
from tqdm import tqdm


__version__     = "1.0.4"
__doc__         = """
This tool aims to detect the packer used on an input executable, folder of executables or Dataset.
"""
__examples__    = []
__description__ = "Detect the packer used on an input executable/folder/dataset"


if __name__ == '__main__':
    parser.add_argument("executable", help="executable or folder containing executables or dataset")
    parser.add_argument("-b", "--binary", action="store_true", help="only consider if packed or not")
    parser.add_argument("-d", "--detector", action="extend", nargs="*", type=Detector.get,
                        help="detector(s) to be used", note="Uses the superdetector by default")
    grp = parser.add_mutually_exclusive_group()
    grp.add_argument("-f", "--failures-only", action="store_true", help="output failures only")
    grp.add_argument("-m", "--metrics-only", action="store_true", help="output metrics only")
    parser.add_argument("-t", "--threshold", type=float, help="threshold for voting when using multiple detectors")
    parser.add_argument("-w", "--weak", action="store_true", help="also consider weak assumptions")
    initialize(noargs_action="usage", multi_level_debug=True)
    logging.configLogger(logger, ["INFO", "DEBUG"][args.verbose], fmt=LOG_FORMATS[args.verbose], relative=True)
    kw = {'debug': args.verbose > 0, 'verbose': args.verbose > 1, 'multiclass': not args.binary,
          'silent': args.verbose == 0, 'threshold': args.threshold, 'weak': args.weak}
    stats, cmatrix, pbar = {}, {'fn': 0, 'fp': 0, 'tn': 0, 'tp': 0}, None
    try:
        # using a single detector
        if len(args.detector or []) == 1:
            logger.name = "detector"
            for out in Detector.get(args.detector[0]).detect(args.executable, **kw):
                # ([exe]cutable, [r]esulting label of detector, actual [l]abel) 
                try:
                    exe, r, l = out               # when actual label given beforehand (e.g. for performance check)
                except TypeError:
                    exe, r, l = None, None, None  # when r == None, meaning that the executable could not be handled
                except ValueError:
                    exe, r = out                  # when no actual label provided but detection worked
                    l = None
                if pbar is None and hasattr(exe, "len") and exe.len > 1:
                    pbar = tqdm(total=exe.len, unit="executable")
                mc = kw['multiclass']
                not_packed = r == "" and mc or r is False and not mc
                if not args.metrics_only:
                    disp = "not packed" if not_packed else r if mc else "packed"
                    if not args.failures_only or r != l and r is not None and l is not None:
                        log = [logger.failure, logger.success][r == l] if l is not None else logger.debug
                        log("{}: {}".format(exe, disp))
                if l is None:
                    stats.setdefault(r, 0)
                    stats[r] += 1
                elif r is not None:
                    cmatrix[['tp', 'tn'][not_packed] if r == l else ['fp', 'fn'][not_packed]] += 1
                if pbar is not None:
                    pbar.update()
        # using part or all of the available detectors
        else:
            logger.name = "superdetector"
            if len(args.detector or []) != 0:
                kw['select'] = args.detector
            for out in Detector.detect(args.executable, **kw):
                try:
                    exe, r, l, details = out
                except ValueError:
                    exe, r, l = out
                    details = {}
                logger.debug("final decision: %s" % ("not packed" if r == "" else str(r)))
                if pbar is None and hasattr(exe, "len") and exe.len > 1:
                    pbar = tqdm(total=exe.len, unit="executable")
                if not args.metrics_only:
                    mlen = 0
                    for name in details.keys():
                        mlen = max(mlen, len(name))
                    msg = "Decisions:"
                    for name, label in details.items():
                        msg += ("\n{: <%d}: {}" % mlen).format(name, label or "-")
                    if msg != "Decisions:":
                        logger.warning(msg)
                    if not args.failures_only or r != l:
                        log = [logger.failure, logger.success][r == l] if l is not None else logger.debug
                        log("{}: {}".format(exe, r))
                mc = kw['multiclass']
                not_packed = r == "" and mc or r is False and not mc
                if l is None:
                    stats.setdefault(r, 0)
                    stats[r] += 1
                elif r is not None:
                    cmatrix[['tp', 'tn'][not_packed] if r == l else ['fp', 'fn'][not_packed]] += 1
                if pbar is not None:
                    pbar.update()
    except Exception as e:
        (logger.exception if args.verbose > 0 else logger.error)(e)
        if args.metrics_only:
            print("E,E,E,E")
        sys.exit(1)
    if pbar is not None:
        pbar.close()
    ph, h, m = PERF_HEADERS, ["Accuracy", "Precision", "Recall", "F-Measure"], metrics(**cmatrix)
    m = [ph[k](v) if v >= 0 else "-" for k, v in zip(h, m)]
    n = sum(cmatrix.values())
    logger.debug(cmatrix)
    logger.debug(stats)
    r = [Section("Detection results: ")]
    if n > 0:
        if args.metrics_only:
            print(",".join(m))
        elif n == 1:
            print(r)
        else:
            r.append(Table([m], column_headers=h))
            print(mdv.main(Report(*r).md()))
    else:
        if args.metrics_only:
            print("-,-,-,-")
        else:
            data, tot = [], sum(stats.values())
            np = stats.pop("", 0)
            if np > 0:
                data.append(["not-packed", np, "%.2f" % (100 * np / tot)])
            for l, c in sorted(stats.items(), key=lambda x: x[0]):
                data.append([l, c, "%.2f%%" % (100 * c / tot)])
            r.append(Table(data, column_headers=["Label", "Count", "Percentage"]))
            print(mdv.main(Report(*r).md()))

